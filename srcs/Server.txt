no server constructor
-> agarramos os argumentos port e password e inicializamos .
-> agora usamos a funcao socket (socket(AF_INET, SOCK_STREAM, 0);)
    
    * 1ro argumento(domain)AF_INET -> IPv4 Internet protocol
    
    * 2do argumento(tipo de socket)SOCK_STREAM -> rovides sequenced,
        reliable, two-way, connection-based byte streams.
-> se a var serverFd < 0, e pk houve erro na criacao do socket

********
fcntl() -> aplica mudancas no fd em questao
        1ro arg e o fd em questao  
        
        2do arg e a flag que corresponde as 
        mudancas que queremos efetuar

        3ro depende do tipo de cmd que pedes ao fcntl fazer
********

-> fcntl(serverFd, F_SETFL, fcntl(serverFd, F_GETFL, 0) | O_NONBLOCK);
    | PRIMEIRO VAMOS ANALISAR O fcntl QUE ESTA DENTRO DO PROPRIO |
        -> fcntl(serverFd, F_GETFL, 0)
            -> serverFd e o fd com que vamos trabalhar
            ->  F_GETFL -> e o cmd que vai analisar o fd e
                           devolver as flags que o proprio fd tem configurado(neste caso o default)
            -> 0 e para ignorar o 3ro argumento

    |AGORA VAMOS ANALISAR O DE FORA|
    fcntl(serverFd, F_SETFL, fcntl(serverFd, F_GETFL, 0) | O_NONBLOCK);
    serverFd -> e o q vamos a alisar, 
    F_SETFL -> vamos configurar as flags do fd(F_GETFL e o getter das flags, o F_SETFL e o setter)
    a fnctl que esta dentro do proprio devolve as flags default e com " | O_NONBLOCK" adicionamos as flags existentes o 
    conceito de nonblocking ao fd.

    \\\\\\ line 25->

     NOTA:

    struct sockaddr_in {
    1    sa_family_t    sin_family;   // Address family (AF_INET)
    2    in_port_t      sin_port;     // Port number (16-bit, network byte order)
    3   struct in_addr sin_addr;     // IP address (struct)
    4   char           sin_zero[8];  // Padding (not used)
    }

    1-> sa_family_t sin_family -> diz as funcoes do socket que protocolo usar (AF_INET e para IPv4)
    2-> in_port_t sin_port -> armazena o numero da porta(port) que iremos usar
                            mas primeiro tem que ser convertida para network byte order com 
                            a funcao htons();
    3-> e o ip address que ira representar o cliente/server dentro do protocolo escolhido, 
        neste caso ipv4 ex: (198.162.1.1) etc || INADDR_ANY is assign it as a "stream socket"  

    4 sin_zero is only a filling to make the struct sockaddr_in and sockaddr the same size.
    
    the bind() function will assign the atributes ofthe struct 
    serverAddr to the "serverFd" 

    now we have the socket of the server with all the atributes necessary
    now that we have the socket ready, we will wait for calls. how? with the function listen()
    that will wait for any connection to the socket in question.

    struct pollfd {
    int fd;         // File descriptor to poll
    short events;   // Requested events (e.g. POLLIN, POLLOUT)
    short revents;  // Returned events (filled by poll())
    }

    linha(39) -> pollfd serverPollFd = {serverFd, POLLIN, 0};
        e so a inicializacao da struct poll para prestar atencao a qualquer input para o server.
    linha(40) -> pollFds.push_back(serverPollFd);
        estou a meter a struct do poll no vetor pollFds. (de momento so tem 1 struct no vetor)


    //////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////

    a funcao serverListen(void)
        -> sera um loop infinito a espera de input dos polls pollFds
            a funcao poll vai esperar output de QUALQUER FD que esteja registado no vetor.
            no momento em que aja algo para registar 
                entramos num for loop para verificar que fd e que tem info pendente.
                verificamos no vetor de fds, qual e o que tem I/O fd do server
                    -> se o cliente(fd) tiver o i/o do server, quer dizer que este esta
                    a tentar comunicar se com o proprio server 

        -> na linha (53) -> temos um for loop que ira iterar sobre 
            os elementos do vetor que tera o servidor no index 0 e os clientes no resto.
            caso haja algum tipo de revent == POLLIN, quer dizer que nesse socket esta a tentar entrar info
            se estivermos no primeiro index(que normalmente e onde o server socker esta) se houver entrada de info e estamos no fd server, entramos
            estamos a receber a coneccao de um novo cliente

                if new client -> newClient()->
                    aceitamos a coneccao com a funcao accept()  -> o primeiro argumento e o socket do server
                                                                -> o segundo e o pointer para a struct do poll
                                                                    assim teremos a conecao feita entre cliente e server.
                                                                -> o o terceiro e o tamanho da struct do poll para conectar
                
        -> o cliente ao ser aceite e criado entrará no vetor e neste caso era parte do vetor clientes, 
            como é o primeiro estará no index 1
        -> depois defines o fd socket como non blocking para n afetar o loop para isso teras que definir 
            o new_pollfd com todas as pre definicoes
    
        VOLTANDO AO LOOP infinito   -> se o fd que tem info pendente nao for o servidor, quer dizer que o cliente que ja existentes
                                        esta a tentar enviar algo . 
                                            if bytes < 0 Error
                                            else  iremos mandar  a msg e entramos na funcao hanfle msg
                    
                    -> handle_msg()
                        -> aqui criamos um buffer com o tamanho da msg 
                        -> a msg n pode ser maior do que 512. why?
                            se for tiver o tamanho certo para ser enviada verificamos se o cliente tem a 
                            autorizacao necessaria  